use std::collections::HashMap;

use serde::{Deserialize, Serialize};

#[derive(
    Serialize,
    Deserialize,
    Debug,
    Clone,
    PartialEq,
    Eq,
    Hash,
    derive_more::Display,
    derive_more::From,
    derive_more::FromStr,
    derive_more::Deref,
    derive_more::Constructor,
    derive_more::Into,
)]
pub struct HandleName(String);

#[derive(Deserialize, Serialize, Debug, Clone)]
#[serde(untagged)]
pub enum MiddleInputHandle {
    Input(InputHandle),
    #[allow(dead_code)]
    Group {
        group: String,
    },
}

#[derive(Deserialize, Serialize, Debug, Clone)]
#[serde(untagged)]
pub enum MiddleOutputHandle {
    Output(OutputHandle),
    #[allow(dead_code)]
    Group {
        group: String,
    },
}

#[derive(Deserialize, Serialize, Debug, Clone)]
struct TempInputHandle {
    pub handle: HandleName,
    pub description: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub json_schema: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nullable: Option<bool>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        with = "::serde_with::rust::double_option"
    )]
    pub value: Option<Option<serde_json::Value>>,
    #[serde(skip_serializing_if = "std::ops::Not::not", default)]
    pub serialize_for_cache: bool,
}

impl From<TempInputHandle> for InputHandle {
    fn from(temp: TempInputHandle) -> Self {
        let TempInputHandle {
            handle,
            description,
            json_schema,
            kind,
            nullable,
            value,
            serialize_for_cache,
        } = temp;
        let value = if temp.nullable.is_some_and(|nullable| nullable) {
            if value.is_none() {
                Some(None)
            } else {
                value
            }
        } else {
            value
        };
        Self {
            handle,
            description,
            json_schema,
            kind,
            nullable,
            value,
            remember: false,
            is_additional: false,
            serialize_for_cache,
        }
    }
}

#[derive(Serialize, Debug, Clone, Deserialize)]
#[serde(from = "TempInputHandle")]
pub struct InputHandle {
    pub handle: HandleName,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub json_schema: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nullable: Option<bool>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        with = "::serde_with::rust::double_option"
    )]
    pub value: Option<Option<serde_json::Value>>,
    #[serde(default, skip_serializing)]
    pub remember: bool,
    /// Indicates whether this handle is an additional handle. This field is set by the manifest reader and is not present in the original manifest.
    /// Additional handles are defined in the flow node, not in the block.
    #[serde(default, skip_serializing_if = "std::ops::Not::not")]
    pub is_additional: bool,
    #[serde(skip_serializing_if = "std::ops::Not::not")]
    pub serialize_for_cache: bool,
}

impl InputHandle {
    pub fn new(handle: HandleName) -> Self {
        Self {
            handle,
            value: None,
            json_schema: None,
            kind: None,
            description: None,
            nullable: None,
            remember: false,
            is_additional: false,
            serialize_for_cache: false,
        }
    }
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct OutputHandle {
    pub handle: HandleName,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    // The actual format is the JSON Schema specification format plus a contentMediaType field.
    // However, in Rust, it's difficult to describe such a structure (JSON + extra field).
    // Unless we define the JSON Schema format as a struct and then add a contentMediaType field,
    // but for now, there's no strong need for that.
    pub json_schema: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nullable: Option<bool>,
    /// Indicates whether this handle is an additional handle. This field is generated by the manifest reader not originally defined in the manifest.
    /// additional handle is not defined in block , it is defined in the flow node.
    #[serde(default, skip_serializing_if = "std::ops::Not::not")]
    pub is_additional: bool,
    /// This field is used to indicate whether the handle should be serialized for cache. Field with '_' prefix is generated in runtime
    #[serde(default, skip_serializing_if = "std::ops::Not::not")]
    pub _serialize_for_cache: bool,
}

pub type InputHandles = HashMap<HandleName, InputHandle>;

pub fn to_input_handles(inputs: Option<Vec<InputHandle>>) -> Option<InputHandles> {
    inputs.map(|inputs| {
        inputs
            .into_iter()
            .map(|input| (input.handle.to_owned(), input))
            .collect()
    })
}

pub type OutputHandles = HashMap<HandleName, OutputHandle>;

pub fn to_output_handles(outputs: Option<Vec<OutputHandle>>) -> Option<OutputHandles> {
    outputs.map(|outputs| {
        outputs
            .into_iter()
            .map(|output| (output.handle.to_owned(), output))
            .collect()
    })
}

#[cfg(test)]
mod tests {

    #[test]
    fn serialize_content_media_type_output_handle() {
        use super::*;
        let output_handle = OutputHandle {
            handle: HandleName::new("output".to_string()),
            json_schema: Some(serde_json::json!({
                "contentMediaType": "oomol/secret"
            })),
            kind: Some("var1".to_string()),
            description: None,
            nullable: None,
            is_additional: false,
            _serialize_for_cache: false,
        };
        let serialized = serde_json::to_string(&output_handle).unwrap();
        assert_eq!(
            serialized,
            r#"{"handle":"output","json_schema":{"contentMediaType":"oomol/secret"},"kind":"var1"}"#
        );

        let deserialized: OutputHandle = serde_json::from_str(&serialized).unwrap();
        assert_eq!(output_handle.handle, deserialized.handle);
    }

    #[test]
    fn deserialize_content_media_type_output_handle() {
        use super::*;
        let serialized = r#"{"handle":"output","json_schema":{"contentMediaType":"oomol/secret"},"kind":"var1"}"#;
        let deserialized: OutputHandle = serde_json::from_str(serialized).unwrap();
        assert_eq!(deserialized.handle, HandleName::new("output".to_string()));

        match deserialized.json_schema.unwrap() {
            serde_json::Value::Object(obj) => {
                assert_eq!(obj.len(), 1);
                assert_eq!(
                    obj.get("contentMediaType"),
                    Some(&serde_json::Value::String("oomol/secret".to_string()))
                );
            }
            _ => panic!("Expected HandleJsonSchema"),
        }

        assert_eq!(deserialized.kind, Some("var1".to_string()));
    }

    #[test]
    fn deserialize_null_and_missing_value_in_input_handle() {
        use super::*;
        let serialized = r#"{"handle":"input"}"#;
        let deserialized: InputHandle = serde_json::from_str(serialized).unwrap();
        assert_eq!(deserialized.handle, HandleName::new("input".to_string()));
        assert_eq!(deserialized.value, None);

        let serialized = r#"{"handle":"input","value":null}"#;
        let deserialized: InputHandle = serde_json::from_str(serialized).unwrap();
        assert_eq!(deserialized.handle, HandleName::new("input".to_string()));
        assert_eq!(deserialized.value, Some(None));

        // yaml 中 只有 key，没有值的时候，应该被解析为 Null
        let serialized = r#"{"handle":"input","value":}"#;
        let deserialized: InputHandle = serde_yaml::from_str(serialized).unwrap();
        assert_eq!(deserialized.handle, HandleName::new("input".to_string()));
        assert_eq!(deserialized.value, Some(None));
    }

    #[test]
    fn deserialize_nullable_field_modify_value_filed() {
        use super::*;
        let serialized = r#"{"handle":"input","nullable":true}"#;
        let deserialized: InputHandle = serde_json::from_str(serialized).unwrap();
        assert_eq!(deserialized.handle, HandleName::new("input".to_string()));
        assert_eq!(deserialized.value, Some(None));

        let serialized = r#"{"handle":"input","nullable":false}"#;
        let deserialized: InputHandle = serde_json::from_str(serialized).unwrap();
        assert_eq!(deserialized.handle, HandleName::new("input".to_string()));
        assert_eq!(deserialized.value, None);

        let serialized = r#"{"handle":"input","value":null,"nullable":true}"#;
        let deserialized: InputHandle = serde_json::from_str(serialized).unwrap();
        assert_eq!(deserialized.handle, HandleName::new("input".to_string()));
        assert_eq!(deserialized.value, Some(None));

        let serialized = r#"{"handle":"input","value":null,"nullable":false}"#;
        let deserialized: InputHandle = serde_json::from_str(serialized).unwrap();
        assert_eq!(deserialized.handle, HandleName::new("input".to_string()));
        assert_eq!(deserialized.value, Some(None));

        let serialized = r#"{"handle":"input","value":"a","nullable":false}"#;
        let deserialized: InputHandle = serde_json::from_str(serialized).unwrap();
        assert_eq!(deserialized.handle, HandleName::new("input".to_string()));
        assert_eq!(deserialized.value, Some(Some("a".into())));

        let serialized = r#"{"handle":"input","value":"a","nullable":true}"#;
        let deserialized: InputHandle = serde_json::from_str(serialized).unwrap();
        assert_eq!(deserialized.handle, HandleName::new("input".to_string()));
        assert_eq!(deserialized.value, Some(Some("a".into())));
    }

    #[test]
    fn deserialize_yaml_input_handle() {
        use super::*;
        let serialized = r#"{"handle":"input","value":,"nullable":false}"#;
        let deserialized: InputHandle = serde_yaml::from_str(serialized).unwrap();
        assert_eq!(deserialized.handle, HandleName::new("input".to_string()));
        assert_eq!(deserialized.value, Some(None));
    }
}
